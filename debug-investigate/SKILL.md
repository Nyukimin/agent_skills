---
name: debug-investigate
description: バグ症状から仮説駆動で原因を追跡する。analyze-codebase 出力があれば活用し、なければソースコードから直接調査する。
argument-hint: "<バグ症状> <--log ログファイル> <--trace スタックトレース> <--module 対象モジュール> <--freq 発生頻度>"
---

# Debug Investigation — 仮説駆動型バグ調査

バグ症状 `$0` を起点に、仮説→検証→棄却の反復ループで根本原因を特定する。

---

## 入力の解析

```
$0: バグ症状（必須）— テキスト記述
オプション引数（$0 内に含まれる場合は解析して抽出）:
  --log <path>      : RTTログ、シリアルログ等
  --trace <path>    : スタックトレース、Ozone出力等
  --module <name>   : 疑わしいモジュール名（ヒント）
  --freq <text>     : 発生頻度（「年1回」「毎回」等）
```

---

## 共通ルール

1. **serena MCP のシンボル解析ツールを優先**
   - `get_symbols_overview` → `find_symbol` → `find_referencing_symbols` の順で使う
   - ファイル全体の読み込みは最小限にする

2. **推測と事実を区別**
   - コードから確認した事実はそのまま記述
   - 推測は「※推測」タグを付ける

3. **半自動制御**
   - 仮説の選択・検証の進行はユーザーが承認する
   - 勝手に次の仮説に進まない
   - AskUserQuestion で確認を取ってから進む

4. **必須チェックリスト**
   - Phase 1 と Phase 3 で `checklists/bias_prevention.md` を必ず実行する
   - チェック結果をユーザーに報告する

5. **analyze-codebase 出力の適応的活用**
   - `docs/codebase-map/` が存在すれば入力として読み込む
   - 存在しなければ serena でソースコードから直接探索する
   - どちらの場合でも同じ品質の調査を行う

6. **出力先**
   - 調査レポート: `docs/調査/YYYYMMDD_HHMMSS_タイトル.md`
   - サマリ: serena メモリ（将来の調査で参照可能に）

---

## Phase 0: コンテキスト収集（適応型）

### 既存調査記録の検索

1. `docs/調査/` 内のファイルを Glob で一覧取得
2. ファイル名とバグ症状のキーワードマッチで関連する調査を特定
3. 関連する調査レポートを Read で読み込み、以下を把握:
   - 過去の結論（根本原因として何が特定されたか）
   - 棄却された仮説（何が除外されたか）
   - 関連するソースファイル・関数
4. 既存知見を「既存調査コンテキスト」として記録し、以降のフェーズで活用

### 既存ドキュメントの確認

1. `docs/codebase-map/` の存在を確認する
2. **存在する場合**:
   - 症状に関連するモジュール解析を Read で読み込む
   - ユースケース逆引きから関連する処理フローを読み込む
   - 結合ポイントマップからモジュール間関係を把握する
   - → 「既存知識ベースあり」として Phase 1 へ
3. **存在しない場合**:
   - serena で akerun プロジェクトをアクティベートする
   - `get_symbols_overview` で対象モジュールの構造を把握する
   - `search_for_pattern` で症状に関連するキーワードを検索する
   - → 「ソースコード直接探索」として Phase 1 へ

### 追加入力の処理

- `--log` 指定あり → ログファイルを Read で読み込み、エラー箇所・異常値を抽出
- `--trace` 指定あり → スタックトレースを解析し、クラッシュ箇所を特定
- `--module` 指定あり → 対象モジュールを優先的に解析
- `--freq` 指定あり → 頻度制約として記録（Phase 1 で仮説フィルタに使用）

---

## Phase 1: 仮説形成（ユーザーに提示）

### 既存知見との照合

- 既存調査で既に特定された原因がある場合、それを明示する
- 既存調査で棄却された仮説は、新たな証拠がない限り再提案しない
- 既存調査との関連性をユーザーに報告する

### 仮説生成

1. Phase 0 の情報を統合し、仮説を**最大3つ**生成する
2. 各仮説について以下を記述する:
   - **仮説の内容**（1-2文）
   - **根拠**（どの情報からこの仮説に至ったか）
   - **検証方法**（何を調べれば確認/棄却できるか）
   - **予想される影響範囲**

### ★必須チェックリスト実行★

`checklists/bias_prevention.md` の全項目を実行し、結果を記録する:

- □ **確証バイアス**: 各仮説の「反証」を1つ挙げる
- □ **頻度制約**: 仮説の発生条件は `--freq` と矛盾しないか
- □ **ライフサイクル**: ペア操作（enable/disable等）が関与するか

### ユーザー確認

AskUserQuestion で以下を確認する:
- どの仮説を先に検証するか
- 追加の情報やヒントがあるか

---

## Phase 2: 証拠収集（承認された仮説について）

### 既存知見の活用

サブエージェントに証拠収集を委託する場合、プロンプトに以下を含めること:
- Phase 0 で収集した既存調査の知見
- 「既存調査と矛盾する結論を出す場合、その理由を明示すること」という指示

### コード解析

1. serena のツールで証拠を収集する:
   - `find_symbol`: 疑わしい関数の body を取得
   - `find_referencing_symbols`: 呼び出し元/先を追跡
   - `search_for_pattern`: 関連パターンを網羅的に検索

### 実行コンテキストの確認

2. 対象関数がどのコンテキストで実行されるか確認する:
   - `search_for_pattern` で `k_work_submit`, `K_THREAD_DEFINE`, `k_timer_init` を検索
   - ワークキュー（workq_h/m/l）、ISR、専用スレッドのいずれかを特定

### リソースライフサイクルの確認

3. ペア操作が関与する場合（チェックリストで特定済み）:
   - enable/disable, start/stop, alloc/free のペアを追跡
   - **全パス**（正常/エラー/タイムアウト）での解放を確認
   - **補償パス**（別の場所での解放）の有無を確認
   - 片方だけ見て判断しない（MEMORY.md 教訓）

### 中間報告

4. 収集した証拠を整理してユーザーに中間報告する

---

## Phase 3: 検証と判定（ユーザーに報告）

### 証拠との照合

1. 仮説と証拠を照合する:
   - 仮説を**支持する**証拠
   - 仮説と**矛盾する**証拠
   - 判定: **確認** / **棄却** / **保留**（証拠不足）

### ★必須チェックリスト再実行★

2. `checklists/bias_prevention.md` を再度実行する:
   - □ 「確認」と判定した場合: **本当に反証はないか？**
   - □ 完全なライフサイクルを追跡したか？（片方だけ見ていないか）
   - □ 発生頻度と矛盾しないか？

### 判定結果の報告

3. ユーザーに判定結果を報告する:
   - **確認** → 根本原因として記録し、修正案を提示
   - **棄却** → 棄却理由を記録し、Phase 1 に戻って次の仮説へ
   - **保留** → 追加で必要な情報をユーザーに確認

---

## Phase 4: レポート生成

1. `templates/investigation_report.md` に従って調査レポートを生成する
2. `docs/調査/YYYYMMDD_HHMMSS_タイトル.md` として保存する
3. serena メモリにサマリを保存する（将来の調査で参照可能に）

---

## フロー全体図

```
入力: バグ症状 [+ログ] [+トレース] [+モジュールヒント] [+頻度]
  │
  ▼
Phase 0: コンテキスト収集
  ├── docs/調査/ → 既存調査記録の検索
  ├── docs/codebase-map/ あり → ドキュメント読み込み
  └── なし → serena でソース探索
  │
  ▼
Phase 1: 仮説形成（最大3つ）
  ├── ★チェックリスト実行★
  └── → ユーザーに提示、承認を得る
  │
  ▼
Phase 2: 証拠収集
  ├── serena シンボル解析
  ├── 実行コンテキスト確認
  └── リソースライフサイクル確認
  │
  ▼
Phase 3: 検証と判定
  ├── ★チェックリスト再実行★
  ├── 確認 → Phase 4（レポート生成）
  ├── 棄却 → Phase 1 に戻る（次の仮説）
  └── 保留 → ユーザーに追加情報を確認
  │
  ▼
Phase 4: レポート生成
  └── docs/調査/YYYYMMDD_HHMMSS_タイトル.md
```
