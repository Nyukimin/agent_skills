---
name: analyze-codebase
description: ソースコードを階層的に解析しドキュメント化する（Hierarchical Summarization）。LLM の「部分的に読んで理解した気になる」問題を解決するため、複数粒度で往復解析する。
argument-hint: "<対象ディレクトリ> <phase1|phase2|all> <--refs 外部資料ディレクトリ>"
---

# Hierarchical Codebase Analysis

ソースコード `$0` を階層的に解析し、ドキュメント化する。

## 実行フェーズ: $1


## 入力の解析

```
$0: 対象ディレクトリ（デフォルト: akerun/src/）
$1: 実行フェーズ（phase1 | phase2 | all）
オプション引数:
  --refs <path>  : 外部資料ディレクトリ（設計書、仕様書等）
```

---

## 共通ルール

1. **serena MCP のシンボル解析ツールを優先**
   - `get_symbols_overview` → `find_symbol` → `find_referencing_symbols` の順で使う
   - ファイル全体の読み込みは最小限にする
   - まず .h（公開API）を読み、必要に応じて .c を参照

2. **推測と事実を区別**
   - コードから確認した事実はそのまま記述
   - 推測は「※推測」タグを付ける

3. **各ステップ完了時にファイル書き出し**
   - 中断しても再開可能にする
   - docs/ に正式版、serena メモリにサマリを保存

4. **出力先**
   - ドキュメント: `docs/codebase-map/` 配下
   - サマリ: serena メモリ（`mcp__serena__write_memory`）

5. **地図原則: ソースコードに書かれていない情報を書く**
   - ドキュメントはソースコードの「代替」ではなく「地図 + 注意書き」
   - ユーザーはソースコード + ドキュメントの両方を LLM に渡す前提
   - シグネチャや実装詳細はソースを見れば分かるので転記しない
   - 代わりに: 役割（Why）、関係性、構造マップ、落とし穴を記述する

---

## Phase 0: 外部資料マッピング・既存調査記録

既存調査記録の活用は常に実行する。外部資料マッピング（--refs）は指定時のみ実行。

### 前提条件

- PDF の図を読み込むには `poppler` が必要（`brew install poppler`）
- `pdftotext`（テキスト抽出）と `pdftoppm`（ページ画像変換）を使用する

### 手順

1. --refs ディレクトリ内の .md / .pdf ファイルを一覧取得
2. 各ファイルの内容を取得:
   - **.md ファイル**: Read ツールで直接読み込み（タイトル + 冒頭10行程度）
   - **.pdf ファイル**: 以下の2段階で読み込み
     a. Bash で `pdftotext <file> -` を実行しテキスト全文を取得（目次・構造の把握）
     b. テキストから図を含むページを特定（「図」「レイヤー」「フロー」「構成」等のキーワード、または目次構造から推定）
     c. 該当ページのみ Bash で `pdftoppm -png -r 200 -f N -l N <file> /tmp/pdf_<name>` で PNG 変換
     d. Read ツールで PNG を読み込み、図の内容（アーキテクチャ図、フロー図、状態遷移図等）を把握
3. 6つのモジュールグループとキーワードマッチでマッピングを生成:
   - ファイル名・タイトル・図の内容から機能キーワードを抽出
   - 各モジュールグループの対象ディレクトリ名・機能と照合
   - 1つの設計書が複数グループにマッチしてもよい
4. マッピング結果を `docs/codebase-map/refs_mapping.md` に書き出す
   - debug-investigate 等の他スキルから参照可能にする
   - 会話終了後も永続化される
   - PDF の場合、図を含むページ番号も記録する（subagent に渡すため）
5. Phase 1 の各 subagent プロンプトに、関連設計書のパスと図のページ番号を追加
6. Phase 2 でも同じマッピングを使用し、設計書との乖離を重点検証

### マッピングのキーワード対応例

| モジュールグループ | マッチキーワード |
|-----------------|---------------|
| コア基盤 | 状態遷移, コマンド, イベント, state machine |
| 通信認証 | BLE, NFC, 外部設計, 外部仕様, 通信, 認証 |
| 物理制御 | 施錠, 開錠, モーター, サムターン, ドアセンサー, 強制回転 |
| データ永続化 | FlashROM, メモリ管理, 履歴, ログ, アップロード |
| 付帯機能 | オートロック, ボタン, 音声, バッテリー, 電源, 閾値 |
| テスト基盤 | 製造, テスト, 品質保証, ファームウェアアップデート, DFU |

### 既存調査記録の活用

refs マッピングと並行して、過去の調査記録も検索する:

1. `docs/調査/` 内のファイルを Glob で一覧取得
2. 各調査レポートのタイトルから関連モジュールを推定
3. モジュールグループとのマッピングを生成（refs と同じ形式）
4. Phase 1 の各 subagent プロンプトに関連する過去調査のパスを追加
5. Step 13 で過去調査との重複チェックに使用

---

## Phase 1: トップダウン解析

Phase 1 の詳細手順は [phase1_topdown.md](phases/phase1_topdown.md) を参照。

### 概要

| ステップ | 内容 | 出力 |
|---------|------|------|
| 1 | コア基盤モジュール解析（state_machine, event, action, command） | `modules/コア基盤.md` |
| 2 | 通信認証モジュール解析（ble, nfc_auth, subsys） | `modules/通信認証.md` |
| 3 | 物理制御モジュール解析（motor, drivers, hal, thumbturn） | `modules/物理制御.md` |
| 4 | データ永続化モジュール解析（data, logger, physical_log, shared） | `modules/データ永続化.md` |
| 5 | 付帯機能モジュール解析（autolock, button, audio, power） | `modules/付帯機能.md` |
| 6 | テスト基盤モジュール解析（lifetest, factory, stress_test, debug_print, main.c） | `modules/テスト基盤.md` |
| 7 | モジュール結合ポイントマップ（Step 1-6 を統合） | `結合ポイントマップ.md` |
| 8 | ユースケース逆引きリファレンス（Step 1-7 を統合） | `ユースケース逆引き.md` |
| 9 | アーキテクチャ総合レポート（全体統合） | `アーキテクチャ総合.md` |

### 実行方法

- Step 1-6 は **並列実行可能**（Task ツールで subagent を6つ起動）
- Step 7-8 は Step 1-6 完了後に実行
- Step 9 は Step 7-8 完了後に実行
- 各 Step のテンプレートは [templates/](templates/) を参照

---

## Phase 2: ボトムアップ修正

Phase 2 の詳細手順は [phase2_bottomup.md](phases/phase2_bottomup.md) を参照。

### 概要

| ステップ | 内容 | 対象 |
|---------|------|------|
| 10 | フォルダ概要の修正・補強 | Phase 1 の各モジュール解析を実コードと突合せ |
| 11 | モジュール概要の修正・補強 | 結合ポイントマップ・ユースケースを修正 |
| 12 | 全体概要の最終化 | アーキテクチャ総合を最終版に更新 |
| 13 | 潜在バグ一覧の生成 | 全ドキュメントから潜在バグ・設計書乖離を集約 |

### 実行方法

- Phase 1 のドキュメントを読み込み、実際のコードと照合
- 差分・誤り・不足を特定し、ドキュメントを更新
- 更新箇所には「※Phase 2 で修正」タグを付ける

---

## フェーズ判定

- `$1` が `phase1` → Phase 0（既存調査記録のみ） → Phase 1 を実行
- `$1` が `phase2` → Phase 2 のみ実行（Phase 1 の出力が存在する前提）
- `$1` が `all` または未指定 → Phase 0 → Phase 1 → Phase 2 を順次実行
