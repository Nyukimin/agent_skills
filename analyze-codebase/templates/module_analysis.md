# モジュール解析テンプレート（地図型）

以下のテンプレートに従って各モジュールを解析すること。
ソースコードに書かれていない情報（Why、関係性、構造、落とし穴）を記述する。

**生成時に付与する frontmatter の例**（ファイル先頭に YAML で記載）:
```yaml
---
generated_at: "2025-02-27T15:00:00+09:00"
run_id: run_YYYYMMDD_HHMMSS
phase: 1
step: "1-1"
profile: {profile_name}
artifact: module
module_group_id: {module_group_id}
---
```

**必須セクション**: templates/schema/module_analysis_required_sections.yaml を参照。概要・関連ドキュメントを必ず含めること。

---

## 概要

（このモジュールの役割を2〜3行で要約すること。）

---

## モジュール名: {module_name}

### 役割と責務（Why）
- このモジュールが**なぜ存在するか**（1-3行）
- 他のモジュールとの**境界**（何を担当し、何を担当しないか）

### ナビゲーション

| ファイル | 役割 | 読むべき場面 |
|---------|------|------------|
| `xxx.h` | 公開API定義 | モジュールの使い方を知りたい時 |
| `xxx.c` | メイン実装 | 内部動作を理解したい時 |
| `xxx_app_*.c` | Observer/Middleware | 状態変化の副作用を追う時 |

### モジュール間の関係

- **依存先**: {module} → {target}（{理由}）
- **依存元**: {caller} → {module}（{理由}）
- **状態共有**: SM_State.{member} を Reducer で更新、Observer で監視

### 大関数の構造マップ（50行超の関数のみ）

| 関数名 | 行数 | 構造 | 行範囲の目安 |
|--------|-----|------|------------|
| `_reducer()` | {N}行 | switch {M} case（{グループ1} {n1}, {グループ2} {n2}, ...） | {start}-{end} |
| `_middleware()` | {N}行 | if-else {M}分岐（{概要}） | {start}-{end} |

※ グループ化: 関連する case をカテゴリ（モーター制御、状態管理、エラー処理等）で分類し、各カテゴリの case 数を記載

### 落とし穴・注意点

- {関数/処理} の {状況} は {注意点}（例: fallthrough あり、暗黙の前提条件、副作用）
- {よくある誤解や間違えやすいポイント}
- 【設計書参照時】仕様と実装の乖離:
  - {設計書名}: {仕様上の記述} → 実装: {実際の動作}（{乖離の影響}）

### 設計意図

- なぜ Reducer と Observer を分けているか
- なぜこの優先度か
- なぜこのデータ構造を選んだか

### 初期化

- **module_init() 登録**: あり / なし
- **優先度**: {priority}
- **注意点**: {初期化順に関する注意点があれば記述}

### 関連ドキュメント

- [アーキテクチャ総合.md](../アーキテクチャ総合.md)
- [結合ポイントマップ.md](../結合ポイントマップ.md)
- [ユースケース逆引き.md](../ユースケース逆引き.md)
- 他モジュール解析: modules/{他module_group_id}.md
